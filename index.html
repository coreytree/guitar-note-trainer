<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Guitar Note Recognition Exercise</title>
  <style>
    :root { --bg:#0f1220; --panel:#171a2b; --accent:#6ea8fe; --text:#eef2ff; --muted:#b6c0de; --good:#4ade80; --warn:#f59e0b; --danger:#f87171; }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,#0f1220,#0b0f1a); color:var(--text); }
    header{ position:sticky; top:0; z-index:50; padding:24px 20px 8px; text-align:center; background:#0f1220; border-bottom:1px solid rgba(255,255,255,0.08); box-shadow:0 6px 18px rgba(0,0,0,0.35); }
    h1{ margin:0; font-size:24px; letter-spacing:0.3px; }
    .app{ max-width:980px; margin:0 auto; padding:16px; display:grid; grid-template-columns:340px 1fr; gap:16px; }
    .card{ background:var(--panel); border:1px solid rgba(255,255,255,0.08); border-radius:16px; padding:16px; box-shadow:0 8px 24px rgba(0,0,0,0.35); }
    .card h2{ margin:0 0 8px; font-size:16px; color:var(--muted); font-weight:600; }
    textarea{ width:100%; min-height:320px; resize:vertical; background:#0d1020; color:var(--text); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:12px; line-height:1.5; }
    label{ display:block; font-size:13px; color:var(--muted); margin-top:10px; }
    select,input[type="number"]{ width:100%; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:#0d1020; color:var(--text); }
    .row{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    button{ padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:#0d1020; color:var(--text); cursor:pointer; }
    button.primary{ background:#7CB2FF; color:#0b1020; border:1px solid transparent; font-weight:700; }
    button.primary:hover{ background:#5FA5FF; }
    button.primary:active{ background:#4A82CC; }
    button.primary:focus-visible{ outline:2px solid #7CB2FF; outline-offset:2px; }
    button.success{ background:var(--good); color:#0b1020; border:none; font-weight:700; }
    button.danger{ background:var(--danger); color:#0b1020; border:none; font-weight:700; }
    .stack{ display:grid; gap:8px; }
    .mini{ font-size:12px; color:var(--muted); }
    .queue{ max-height:260px; overflow:auto; border-radius:12px; border:1px solid rgba(255,255,255,0.08); }
    .queue li{ list-style:none; margin:0; padding:8px 12px; border-bottom:1px solid rgba(255,255,255,0.06); color:var(--muted); }
    .queue li.active{ color:var(--text); background:rgba(110,168,254,0.12); }
    .kbd{ font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Courier New",monospace; background:#0d1020; padding:1px 6px; border-radius:6px; border:1px solid rgba(255,255,255,0.12); }
    footer{ text-align:center; padding:10px 0 24px; color:var(--muted); font-size:12px; }
    details.dev { margin-top: 10px; }
    details.dev summary { cursor: pointer; color: var(--muted); }
    details.dev pre { background:#0d1020; padding:10px; border-radius:12px; border:1px solid rgba(255,255,255,0.08); max-height:180px; overflow:auto; }
    .badge { padding:2px 8px; border-radius:999px; font-size:11px; display:inline-block; }
    .pass { background:#093; }
    .fail { background:#933; }

    .status-top { font-size:32px; font-weight:900; margin:10px 0 4px; white-space:pre-wrap; }
    .hero-controls { display:flex; justify-content:center; gap:12px; margin:12px 0 6px; }
    .hero-controls .big { font-size:18px; font-weight:800; padding:14px 22px; border-radius:14px; }
    .hero-controls .big:active { transform: translateY(1px); }

    /* String selector */
    .string-select{ display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap; margin:6px 0 0; }
    .string-btn{ padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.15); background:#0d1020; color:var(--text); font-size:13px; cursor:pointer; }
    .string-btn.on{ background:#B8D4FF; color:#0b1020; border-color:transparent; font-weight:700; }

    /* Header help width */
    .header-help{ max-width:820px; margin:8px auto 4px; }

    @media (max-width: 720px) {
      .hero-controls { flex-wrap: wrap; gap:10px; }
      .hero-controls .big { flex:1 1 140px; width:100%; }
      .app { grid-template-columns: 1fr; }
      .card.vt { order: 1; }
      .card.list { order: 2; }
      .header-help{ font-size:11px; line-height:1.4; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Guitar Note Recognition Exercise</h1>
    <div id="status" class="status-top"></div>
    <div class="hero-controls">
      <button id="startTop" class="primary big" aria-label="Play exercise">Play ▶</button>
    </div>
    <div class="mini" style="margin-top:6px;"><strong>Select Strings to Practice (all by default)</strong></div>
    <div class="string-select" aria-label="Choose strings to practice">
      <button id="sel-s1" class="string-btn">1 – E</button>
      <button id="sel-s2" class="string-btn">2 – B</button>
      <button id="sel-s3" class="string-btn">3 – G</button>
      <button id="sel-s4" class="string-btn">4 – D</button>
      <button id="sel-s5" class="string-btn">5 – A</button>
      <button id="sel-s6" class="string-btn">6 – E</button>
    </div>
    <p class="mini header-help">Hit play, then play the spoken note on your guitar. As you get better, you can speed up the rate. You can select the amount of time between spoken notes, choose to have each note spoken twice (repeated), and select specific strings you'd like to practice (all are selected by default). The list is always randomized by default. Tap Regenerate list anytime for a fresh shuffle. If the voice sounds odd, try a different voice in the dropdown. On Safari or iOS, make sure you tap Play once to allow audio. Based on a practice concept from the book "Vaideology" by Steve Vai. Built for focused ear training on note names and string positions.</p>
    <details class="mini header-help" style="text-align:left;">
      <summary>Having trouble on iOS or Safari?</summary>
      <ul class="mini" style="margin:6px 0 0 18px; padding:0;">
        <li>Tap <b>Play</b> once to allow audio, Safari blocks speech until a user interaction.</li>
        <li>If you hear nothing, ensure the device isn’t muted and check Focus modes. On macOS Safari, set <em>Settings → Websites → Auto-Play</em> to <em>Allow All Auto-Play</em>.</li>
        <li>If the first note is skipped, tap <b>Play</b> again.</li>
        <li>Give the voice list a moment to load, or choose another voice if it sounds odd.</li>
      </ul>
    </details>
  </header>
  <main class="app">
    <section class="card vt">
      <h2>Voice and Timing</h2>
      <div class="row">
        <div class="stack">
          <label for="voice">Voice</label>
          <select id="voice"></select>
        </div>
        <div class="stack"></div>
      </div>
      <label><input type="checkbox" id="repeatEach" /> speak each note twice</label>
      <div class="row" style="grid-template-columns: 1fr;">
        <div class="stack">
          <label for="pauseSec">Rate of notes (seconds between)</label>
          <div class="row" style="grid-template-columns: minmax(160px, 1fr) auto auto; gap:10px; align-items:center;">
            <input id="pauseSec" type="number" min="0" value="5" step="0.1" style="height:38px; font-size:15px;" />
            <button id="pauseDec" title="Decrease by 0.5" style="min-width:68px;">–0.5</button>
            <button id="pauseInc" title="Increase by 0.5" style="min-width:68px;">+0.5</button>
          </div>
        </div>
      </div>

      <h2 style="margin-top:14px;">Queue</h2>
      <ol id="queue" class="queue"></ol>

      <details class="dev">
        <summary>Self-check (dev)</summary>
        <div id="testSummary" class="mini"></div>
        <pre id="testLog"></pre>
      </details>
    </section>

    <section class="card list">
      <h2>List</h2>
      <textarea id="list" placeholder="Example:
F# on E string
Bb on A string
C on D string
..."></textarea>
      <label><input type="checkbox" id="shuffle" checked /> Always randomized</label>
      <label><input type="checkbox" id="loop" /> Loop list</label>
      <div class="row" style="margin-top:10px; grid-template-columns:1fr;">
        <button id="regenBtn" class="warn">Regenerate list</button>
      </div>
      <p class="mini">Your list auto saves in this browser.</p>
    </section>
  </main>
  <footer></footer>

  <script>
    const listEl = document.getElementById('list');
    const voiceEl = document.getElementById('voice');
    const pauseSecEl = document.getElementById('pauseSec');
    const pauseDecBtn = document.getElementById('pauseDec');
    const pauseIncBtn = document.getElementById('pauseInc');
    const loopEl = document.getElementById('loop');
    const repeatEachEl = document.getElementById('repeatEach');
    const queueEl = document.getElementById('queue');
    const statusEl = document.getElementById('status');

    const regenBtn = document.getElementById('regenBtn');
    const shuffleEl = document.getElementById('shuffle');
    const startTop = document.getElementById('startTop');
    const stopTop = document.getElementById('stopTop');

    // String selection buttons and state
    const stringBtnIds = ['sel-s1','sel-s2','sel-s3','sel-s4','sel-s5','sel-s6'];
    const idxToLetter = ['E','B','G','D','A','E']; // 1–E,2–B,3–G,4–D,5–A,6–E
    const stringStorageKey = 'guitar-string-select-v1';
    function loadStringSel(){
      const raw = localStorage.getItem(stringStorageKey);
      if(!raw) return [true,true,true,true,true,true];
      const set = new Set(raw.split(',').map(n=>Number(n)));
      return [1,2,3,4,5,6].map(n=> set.has(n));
    }
    let stringSelected = loadStringSel();
    function saveStringSel(){ const on = stringSelected.map((b,i)=> b? (i+1):null).filter(Boolean); localStorage.setItem(stringStorageKey, on.join(',')); }
    function renderStringSel(){ stringBtnIds.forEach((id,i)=>{ const el=document.getElementById(id); if(!el) return; const on = !!stringSelected[i]; el.classList.toggle('on', on); el.setAttribute('aria-pressed', on?'true':'false'); }); }
    function ensureOneOn(){ if(!stringSelected.some(Boolean)) stringSelected = [true,true,true,true,true,true]; }
    stringBtnIds.forEach((id,i)=>{ const el=document.getElementById(id); if(!el) return; el.addEventListener('click', ()=>{ stringSelected[i]=!stringSelected[i]; ensureOneOn(); saveStringSel(); renderStringSel(); buildQueue(); }); });
    renderStringSel();

    // Persistence
    const storageKey = 'guitar-note-caller-list-v1';
    function saveList(){ localStorage.setItem(storageKey, listEl.value); }
    function loadList(){ const v = localStorage.getItem(storageKey); if (v) listEl.value = v; }
    loadList();

    // Voices
    function loadVoices(){
      const voices = window.speechSynthesis.getVoices();
      voiceEl.innerHTML = '';
      const preferred = voices.filter(v => /en/i.test(v.lang));
      const set = preferred.length ? preferred : voices;
      set.forEach((v)=>{ const opt = document.createElement('option'); opt.value = v.name; opt.textContent = `${v.name} (${v.lang})`; voiceEl.appendChild(opt); });
      if (set.length) voiceEl.value = set[0].name;
    }
    window.speechSynthesis.onvoiceschanged = loadVoices; loadVoices();

    // --- Full list generators (standard tuning, frets 0–12) ---
    function generateOrderedFullList(){
      const tuning = [
        {name:'E', midi:40}, // E2
        {name:'A', midi:45},
        {name:'D', midi:50},
        {name:'G', midi:55},
        {name:'B', midi:59},
        {name:'E', midi:64}  // E4
      ];
      const pref = { 'C#':'Db','D#':'Eb','F#':'F#','G#':'Ab','A#':'Bb' };
      const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
      const stringLabels = ['E','A','D','G','B','E'];
      const toName = (semitone)=>{ const n = names[semitone]; return pref[n] || n; };
      const noteName = (midi)=>{ const s = (midi - 12) % 12; return toName((s+12)%12); };
      const lines = [];
      for (let s = 0; s < tuning.length; s++){
        const open = tuning[s].midi;
        for (let fret = 0; fret <= 12; fret++){
          const name = noteName(open + fret);
          lines.push(`${name} on ${stringLabels[s]} string`);
        }
      }
      return lines;
    }
    function generateDefaultList(){
      const lines = generateOrderedFullList();
      const a = lines.slice();
      for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; }
      return a.join('\n');
    }

    // Queue and player
    let queue = []; let idx = -1; let speaking = false; let paused = false; let pendingTimer = null; let repeatEcho = false;

    function parseStringLetter(line){ const m = /on\s+([EADGB])\s+string/i.exec(line); return m ? m[1].toUpperCase() : null; }
    function activeLetters(){ const set = new Set(); stringSelected.forEach((on,i)=>{ if(on) set.add(idxToLetter[i]); }); return set; }

    function buildQueue(){
      let lines = listEl.value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const letters = activeLetters();
      const filtered = lines.filter(l=>{ const L = parseStringLetter(l); return !L || letters.has(L); });
      queue = (shuffleEl && shuffleEl.checked) ? shuffle(filtered) : filtered.slice();
      renderQueue(); idx = -1;
    }
    function renderQueue(){
      queueEl.innerHTML='';
      queue.forEach((item,i)=>{
        const li=document.createElement('li');
        li.textContent=item;
        if(i===idx) li.classList.add('active');
        queueEl.appendChild(li);
      });
    }

    // Speech formatter
    function formatSpeech(text){
      let t = text;
      t = t.replace(/([A-G])[#♯]/g, (_m, p1) => p1 + ' sharp'); // F# => F sharp
      t = t.replace(/([A-G])[b♭]/g, (_m, p1) => p1 + ' flat');  // Bb => B flat
      t = t.replace(/^A(?=\s|$)/, 'A.'); // force letter A
      return t;
    }

    function speak(text){
      const utter = new SpeechSynthesisUtterance(formatSpeech(text));
      const voice = speechSynthesis.getVoices().find(v=> v.name === voiceEl.value);
      if (voice) utter.voice = voice;
      utter.rate = 0.75; // fixed rate
      return new Promise(resolve => {
        utter.onend = resolve;
        utter.onerror = resolve;
        speechSynthesis.speak(utter);
      });
    }

    async function playFrom(startIndex=0){
      buildQueue(); if(!queue.length){ status('Nothing to read'); updatePlayBtn(); return; }
      speaking = true; paused = false; idx = startIndex - 1; status('Starting'); updatePlayBtn();
      while(speaking){
        idx++; if(idx >= queue.length){ if(loopEl.checked){ idx=0; } else { break; } }
        renderQueue(); const line = queue[idx]; status(`${line}`);
        await speak(line); if(!speaking) break;
        await waitForPause(); if(!speaking) break;
        if(repeatEachEl.checked){
          if(!repeatEcho){ repeatEcho = true; idx--; continue; }
          else { repeatEcho = false; }
        }
      }
      status(''); speaking=false; idx=-1; renderQueue(); updatePlayBtn();
    }

    function waitForPause(){
      const secs = Number(pauseSecEl.value || 0);
      let ms = Math.max(0, secs * 1000);
      const tick = 50; // ms granularity so pause is responsive
      return new Promise(async (resolve)=>{
        while (ms > 0) {
          if (!speaking) return resolve();
          // If paused, wait here until resumed
          while (paused) {
            if (!speaking) return resolve();
            await sleep(100);
          }
          const chunk = Math.min(tick, ms);
          await sleep(chunk);
          ms -= chunk;
        }
        resolve();
      });
    }

    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
    function shuffle(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
    function status(t){ statusEl.textContent = t; }

    // Header controls: Play/Pause toggle + Stop
    function updatePlayBtn(){
      if(!startTop) return;
      const isPlaying = speaking && !paused;
      startTop.textContent = isPlaying ? 'Pause ❚❚' : 'Play ▶';
      startTop.setAttribute('aria-label', isPlaying ? 'Pause exercise' : 'Play exercise');
    }
    function togglePlay(){
      if(!speaking){ playFrom(0); updatePlayBtn(); return; }
      if(paused){ speechSynthesis.resume(); paused=false; status(`${queue[idx]||''}`); updatePlayBtn(); }
      else { speechSynthesis.pause(); paused=true; status(`${queue[idx]||''}`); updatePlayBtn(); }
    }
    if (startTop) startTop.onclick = () => togglePlay();
    if (stopTop)  stopTop.onclick  = () => safeStop();

    function safeStop(){
      speaking=false; paused=false; speechSynthesis.cancel();
      if(pendingTimer){ clearTimeout(pendingTimer); pendingTimer=null; }
      status(''); updatePlayBtn();
    }

    // Autosave and rebuild
    listEl.addEventListener('input', ()=>{ saveList(); buildQueue(); });
    if (shuffleEl) shuffleEl.addEventListener('change', buildQueue);

    // Regenerate list button
    regenBtn.onclick = ()=>{
      safeStop();
      listEl.value = generateDefaultList();
      saveList();
      buildQueue();
      status('New randomized list ready');
    };

    // Pause +/- controls
    function setPause(val){ const v = Math.max(0, Number(val) || 0); pauseSecEl.value = v.toFixed(1); }
    if (pauseDecBtn && pauseIncBtn) {
      pauseDecBtn.onclick = () => setPause(Number(pauseSecEl.value) - 0.5);
      pauseIncBtn.onclick = () => setPause(Number(pauseSecEl.value) + 0.5);
    }

    // Shortcuts: Space/S = Play/Pause, X = Stop
    window.addEventListener('keydown', (e)=>{
      if(e.target.closest('input, textarea, select, button')) return;
      if(e.code === 'Space'){ e.preventDefault(); togglePlay(); return; }
      const k=e.key.toLowerCase();
      if(k==='s'){ e.preventDefault(); togglePlay(); }
      if(k==='x'){ e.preventDefault(); safeStop(); }
    });

    // Init: prepopulate with a randomized default list if none is saved
    const versionKey = 'guitar-note-caller-list-version';
    if(!listEl.value.trim()){
      listEl.value = generateDefaultList();
      localStorage.setItem(versionKey, 'v2-shuffled-default');
      saveList();
    } else {
      // If the saved list matches the canonical ordered list, replace it once with a randomized version
      try {
        const ordered = generateOrderedFullList().join('\n');
        const normalizedSaved = listEl.value.trim().replace(/\r/g,'');
        if (normalizedSaved === ordered && localStorage.getItem(versionKey) !== 'v2-shuffled-default'){
          listEl.value = generateDefaultList();
          localStorage.setItem(versionKey, 'v2-shuffled-default');
          saveList();
        }
      } catch(e) { /* noop */ }
    }
    buildQueue();
    updatePlayBtn();

    // ====== Self-checks (non-intrusive) ======
    const testLog = document.getElementById('testLog');
    const testSummary = document.getElementById('testSummary');
    function log(line){ if(testLog) testLog.textContent += line + "\n"; }
    function badge(ok){ return `<span class="badge ${ok?'pass':'fail'}">${ok?'PASS':'FAIL'}</span>`; }
    (function runSelfChecks(){
      if(!testLog || !testSummary) return; // guard if section removed later
      const results = [];
      const t1 = formatSpeech('F# on E string') === 'F sharp on E string'; results.push(t1); log(`${badge(t1)} F# -> F sharp`);
      const t2 = formatSpeech('G♭ on D string') === 'G flat on D string'; results.push(t2); log(`${badge(t2)} G♭ -> G flat`);
      const t3 = formatSpeech('Ab on E string').startsWith('A. flat on E string'); results.push(t3); log(`${badge(t3)} Ab -> A. flat (forces letter A)`);
      const t4 = formatSpeech('A on B string').startsWith('A. on B string'); results.push(t4); log(`${badge(t4)} A on … -> A. on …`);
      const raw = 'A on E string\r\nBb on A string\nC# on D string';
      const parts = raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const t5 = parts.length === 3 && parts[1] === 'Bb on A string'; results.push(t5); log(`${badge(t5)} split /\\r?\\n/ handles CRLF + LF`);
      const origSaved = listEl.value;
      listEl.value = 'A on E string\nBb on A string\nC# on D string';
      let different = false; let last = null;
      for(let i=0;i<10;i++){ buildQueue(); const cur = queue.join('|'); if(last && cur!==last) { different = true; break; } last = cur; }
      const t6 = different; results.push(t6); log(`${badge(t6)} buildQueue randomizes order`);
      const sample = generateDefaultList();
      const lines = sample.split(/\r?\n/);
      const t7 = typeof sample === 'string' && lines.length >= 60; results.push(t7); log(`${badge(t7)} default list length ok (${lines.length} lines)`);
      const t8 = sample.indexOf('\r') === -1; results.push(t8); log(`${badge(t8)} default list uses \\n only (no CR)`);
      testSummary.innerHTML = `${results.every(Boolean) ? 'All self-checks passed' : 'Some checks failed'} (${results.filter(Boolean).length}/${results.length})`;
      listEl.value = origSaved; buildQueue();
    })();
  </script>
</body>
</html>
